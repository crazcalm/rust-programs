<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 3 - Rust Programs</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Custom REPL Style -->
<style>
  .repl {
    margin-block: 2rem;
    position: relative;
    isolation: isolate;
  }
  .repl iframe {
    width: 100%;
    height: 100%;
    border: none;
  }
  .repl iframe.hide {
    top: 0;
    left: 0;
    opacity: 0;
    position: absolute;
    pointer-events: none;
    z-index: -1;
  }
</style>
<h1 id="chapter-3-elementary-data-structures"><a class="header" href="#chapter-3-elementary-data-structures">Chapter 3: Elementary Data Structures</a></h1>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Perhaps the most fundamental data structure is the <em>array</em>, which is defined as a primitive in C and most other programming languages. An array is a fixed number of data items that are stored contiguously and that are accessed by an index. We refer to the ith element of the array <code>a</code> as <code>a[i]</code>. It is the responsibility of the programmer to store something meaningful in an array position <code>a[i]</code> before referring to it; neglecting this is on of the most common programming mistakes.</p>
<p>A simple example of the useof an array is given by the following program, which prints out all the prime numbers less than 1000. The method used, which dates back to the 3rd century B.C., is called the "sieve of Erathosthenes":</p>
<h3 id="sieve-of-erathosthenes"><a class="header" href="#sieve-of-erathosthenes">Sieve of Erathosthenes</a></h3>
<p>The algorithm works by creating an array with indices 0 to 1000. The indice will represent the number and the value associated with the indice will be a boolean that denotes if the number is prime.</p>
<p>We start of by setting all of the values to the indices to True to represent them potentially being prime. Then we systematically use variables <code>i</code> and <code>j</code> to construct all the products (<code>i*j</code>) that are less then 1000 and set the values to those indices to False. At the end of this process, all the indices that are still set to True are prime.</p>
<h4 id="c-implementation"><a class="header" href="#c-implementation">C Implementation</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define N 1000
main()
{
  int i, j, a[N+1];
  for (a[1] = 0, i = 2; i &lt;= N; i++) a[i] = 1;
  for (i = 2; i &lt;= N/2; i++)
    for (j=2; j &lt;= N/i; j++)
      a[i*j] = 0;
  for (i = 1; i &lt;= N; i++)
    if (a[i]) printf("%4d", i);
  printf("\n");
}
</code></pre>
<h4 id="rust-implementation"><a class="header" href="#rust-implementation">Rust Implementation</a></h4>
<pre><pre class="playground"><code class="language-rust">const N: usize = 1000;

fn main() {
    let (mut i, mut j) = (2, 3);
    let mut a: [bool; N + 1] = [false; N + 1];

    // Setting up the initial array
    a[1] = false;
    for value in a.iter_mut() {
        *value = true
    }

    // We know that i*j is not prime,
    // So for each product we can create,
    // we set that index's value to false
    while i &lt;= N / 2 {
        while j &lt;= N / i {
            a[i * j] = false;
            j += 1;
        }
        j = 2;
        i += 1;
    }

    // Printing out all the primes
    for index in 2..N + 1 {
        if a[index] {
            print!("{:4}", index);
        }
    }
    print!("\n");
}</code></pre></pre>
<p>In the Rust implementation, I converted the for loops to while loops but, otherwise, I kept the code more or less the same.</p>
<h2 id="linked-lists"><a class="header" href="#linked-lists">Linked Lists</a></h2>
<p>The second elementary data structure to consider is the <em>linked list</em>, which is defined as a primitive in some programming languages (notably in Lisp) but not in C. However, C does provide basic operations that make it easy to use linked lists.</p>
<p>The primary advantage of linked list over arrays is that linked lists can grow and shrink in size during their lifetime. In particular, their maximum size need not be known in advance. A second advantage of linked lists is that they provide flexibility in allowing the items to be rearranged efficiently. This flexibility is gained at the expense of quick access to any arbitrary item in the list.</p>
<p>A linked list is a set of items organized sequentially, just like an array. In an array, the sequential organization is provided implicitly (by the position in the array); in a linked list, we use an explicit arrangement in which each item is part of a "node" that also contains a "link" to the next node.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note"></a>
</div>
<div>
<p>The book has a lot of amazing diagrams illustrating examples of linked lists. I do not think I can recreate the diagrams well, but I will attempt to do them in mermaid.js.</p>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-1"></a>
</div>
<div>
<p>On another note, they way they discribe linked list makes me think that arrays that automatically increase in size as needed were not the norm them. That said, I do not think that our "automatically increasing in size" arrays every decrease their size when it is no longer needed. So, with respect to this book and to its focus on memory effeciency, it makes sense to use linked list over our automatically increasing in size arrays because it provides almost the same utility with the assurance that temporary increase in memory usage will be reclaimed, which will allow other parts of the program to use it later.</p>
</div>
</div>
<pre class="mermaid">flowchart LR
    A((A)) --&gt; L((L)) 
    L --&gt; I((I))
    I --&gt; S((S))
    S --&gt; T((T))
</pre>
<p><strong>Figure 3.1</strong>: A linked list</p>
<p>Figure 3.1 shows a linked list, with items represented by letters, nodes by circles and links by lines connecting the nodes. We look in detail below at how lists are represented within the computer; for now we'll talk simply in terms of nodes and links.</p>
<p>Even the simple representation of Figure 3.1 exposes two details we must consider. First, every node has a link, so the link in the last node of the list must specify some "next" node. Our convention will be to have a "dummy" node, which we'll call <em>z</em>, for this purpose: The last node of the list will point to <em>z</em>, and <em>z</em> will point to itself. In addition, we normally will have a dummy node at the other end of the list, again by convention. This node, which we'll call <em>head</em>, will pont to the first node in the list. The main purpose of the dummy nodes is to make cerain manipulations with the links, especially those involving the first and last nodes on the list, more convenient. Other conventions are discussed below. Figure 3.2 shows the list structure with these dummy nodes included.</p>
<pre class="mermaid">flowchart LR
    head --&gt; A((A))
    A --&gt; L((L)) 
    L --&gt; I((I))
    I --&gt; S((S))
    S --&gt; T((T))
    T --&gt; z
    z --&gt; z
</pre>
<p><strong>Figure 3.2</strong>: A linked list with its dummy nodes</p>
<p>Now, this explicit representation of the ordering allows certain operations to be performed much more efficiently than would be possible for arrays. For example, suppose that we want to move the T from the end of the list ot the beginning. In an array, we would have to move every item to make room for the new item at the beginning; in a linked list, we just change three links, as shown in Figure 3.3.</p>
<pre class="mermaid">flowchart LR
    head
    A((A))
    L((L))
    I((I))
    S((S))
    T((T))
    z

    head --&gt; T
    A --&gt; L 
    L --&gt; I
    I --&gt; S
    S --&gt; z
    T --&gt; A
    z --&gt; z
</pre>
<p><strong>Figure 3.3</strong>: Rearranging a linked list</p>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-2"></a>
</div>
<div>
<p>In Figure 3.3, I was unable to preserve the ordering while rearranging the links. As such, I can only produce the end result diagram and not the itermediate step.</p>
</div>
</div>
<p>We make the node containing T point to A, the node containing S point to <em>z</em>, and the <em>head</em> point to T. Even if the list was very long, we could make this structural cahnge by changing just three links.</p>
<p>More important, we can talk of "inserting" and item into a linked list (which makes it grow by one in length), an operation that is unnatural and inconvenient in an array. Figure 3.4 shows how to insert X into our example list by ptting X in a node that points to S, then making the node containing I point to the new node.</p>
<p>Similarly, we can speak of "deleting" an item from a linked list (which makes it shrink by one in length). For example, the second list in Figure 3.4 shows how to delete X from the second list simply by making the node containing I point to S, skipping X. Now, the node containing X still exists (in fact it still points to S), and perhaps should be disposed of in some way -- the point is that X is no longer part of the list, and cannot be accessed by following links from the <em>head</em>. We will return to this issue below.</p>
<pre class="mermaid">flowchart LR
    head
    A((A))
    L((L))
    I((I))
    S((S))
    T((T))
    X((X))
    z

    head --&gt; A
    A --&gt; L 
    L --&gt; I
    I --&gt; X
    X --&gt; S
    S --&gt; T
    T --&gt; z
    z --&gt; z
</pre>
<pre class="mermaid">flowchart LR
    head
    A((A))
    L((L))
    I((I))
    S((S))
    T((T))
    X((X))
    z

    head --&gt; A
    A --&gt; L 
    L --&gt; I
    I --&gt; S
	X --&gt; S
    S --&gt; T
    T --&gt; z
    z --&gt; z
</pre>
<p><strong>Figure 3.4</strong>: Insertion into and deletion from a linked list</p>
<p>On the other hand, there are other operations for which a linked list are not well-suited. The most obvious of these is "find the _k_th item" (find an item given its index): in an array this is done simply by accessing <code>a[k]</code>, but in a linked list we have to travel through <em>k</em> links.</p>
<p>Another operation that is unnatural on linked lists is "find the item <em>before</em> a given item." If all we have is the link to T in our sample list, then the only way we can find the link to S is to start as <em>head</em> and travel through the linked list to find the node that points to T. As a matter of fact, this operations is necessary if we want to be able to delete a given node froma linked list: how else do we find the node whose link much be changed? In many applications, we can get around this problem by redesigning the fundemental deletion operation to be "delete the next node." A similar problem can be avoided for insertion by making the fundemental insertion operation "insert a given item <em>after</em> a given node" in the list.</p>
<h3 id="c-implementation-1"><a class="header" href="#c-implementation-1">C Implementation</a></h3>
<p>C provides primitives operations that allow linked lists to be implemented directly. The following code fragment is a sample implementation of the basic functions that we have discussed so far.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

struct node
{ int key; struct node *next;};

struct node *head, *z, *t;

listinitialize()
{
  head = (struct node *) malloc(sizeof *head);
  z = (struct node *) malloc(sizeof *z);
  head-&gt;next = z; z-&gt;next = z; 
}

deletenext(struct node *t)
{t-&gt;next = t-&gt;next-&gt;next;}

struct node *insertafter(int v, struct node *t)
{
  struct node *x;
  x = (struct node *) malloc(sizeof *x);
  x-&gt;key = v; x-&gt;next = t-&gt;next;
  t-&gt;next=x;
  return x;
}

main(){}
</code></pre>
<div id="admonition-note-3" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-3-title">
<div class="admonition-title">
<div id="admonition-note-3-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-3"></a>
</div>
<div>
<p>The original code was a snippet that did not have the import line or a main function. I added those so that the code would compile.</p>
</div>
</div>
<div id="admonition-note-4" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-4-title">
<div class="admonition-title">
<div id="admonition-note-4-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-4"></a>
</div>
<div>
<p>The use of the dummy node <em>head</em> and <em>z</em> do make the implementation easier. For example, the <code>deletenext</code> function never has to worry about <code>t-&gt;next-&gt;next</code> not existing, and the <code>insertafter</code> method never has to <code>t-&gt;next</code> because the first node will always be <em>head</em> and the <em>head</em> node will always have a next.</p>
</div>
</div>
<h3 id="rust-implementation-1"><a class="header" href="#rust-implementation-1">Rust Implementation</a></h3>
<p>I was unable to write this in Rust. It is not possible with Safe Rust because all of these nodes are owned by the linked_list and the main function that is passing them into these methods. I believe this is possible with Unsafe Rust, but I do not know how to write Unsafe Rust and I cannot justify that rabbit hole for this book.</p>
<p>The compromise is that I wrote it in Python.</p>
<h3 id="python-implementation"><a class="header" href="#python-implementation">Python implementation</a></h3>
<div class="repl" data-id="9f24aeff-bed0-494b-95b1-27175f3ab486" data-readonly="false" data-lang="python">
  <iframe class="hide" loading="lazy" name="mdbook-python-repl" allow="clipboard-write" src="https://mr-addict.github.io/mdbook-repl/embed/"></iframe>
</div>
<pre><code class="language-python">class Node:
    def __init__(self, key, node=None):
        self.key = key
        self.next = node

    def __repr__(self):
        return f"Node(key={self.key})"

class LinkedList:
    def __init__(self):
        self.head = Node(None)
        self.z = Node(None)
        self.head.next = self.z
        self.z.next = self.z

    def delete_next(self, node):
        node.next = node.next.next

    def insert_after(self, value, node):
        new_node = Node(value, node.next)
        node.next = new_node
        return new_node

    def __repr__(self):
        result = ""
        current_node = self.head.next
        index = 0
        while current_node != self.z:
            result += f"{index}: {current_node}\n"
            current_node = current_node.next
            index += 1
        return result
    
def main():
    linked_list = LinkedList()
    node_one = linked_list.insert_after(5, linked_list.head)
    node_two = linked_list.insert_after(10, node_one)
    node_three = linked_list.insert_after(15, node_two)

    print(f"{linked_list}")
    print(f"Delete {node_two}\n")

    linked_list.delete_next(node_one)
    print(f"{linked_list}")
    
if __name__ == "__main__":
    main()
</code></pre>
<h4 id="thoughts"><a class="header" href="#thoughts">Thoughts</a></h4>
<p>I'm kind of angry with how easy it was to translate this into Python. I love Rust, but it always hurts when you try to do "simple" things in programming that are actually extremely difficult in Rust and you end up struggling for hours.</p>
<p>That aside, the Python translation was straightforward. I added <code>__repr__</code> methods to both the Node and LinkedList so that I could see the output. The tricky part about that is that the Node method cannot print <code>node.next</code> because <code>z</code> points it itself, so it hits your recursive upper limit and crashes.</p>
<p>For the LinkedList, having the dummy <code>head</code> and <code>z</code> worked wonders in making the <code>insert_after</code> and the <code>delete_next</code> methods simple. It also does not limit the your options for new Nodes because the terminal node <code>z</code> is a pointer check to the class instance and not a equality check. So, in theory, I can add other nodes with the same properties of <code>z</code> to my linked_list and it should work fine.</p>
<p>I also liked how easy it was to skip the dummy nodes when iterating over the list. If you don't look at the implementation, (based off <code>main</code> and the output) you would never know that dummy nodes are being used.</p>
<h3 id="javascript-implementation"><a class="header" href="#javascript-implementation">JavaScript Implementation</a></h3>
<div class="repl" data-id="d6e383fe-bc39-42a0-94f7-685a7c03fa5d" data-readonly="false" data-lang="javascript">
  <iframe class="hide" loading="lazy" name="mdbook-javascript-repl" allow="clipboard-write" src="https://mr-addict.github.io/mdbook-repl/embed/"></iframe>
</div>
<pre><code class="language-javascript">class Node {
    constructor(key, node) {
        this.key = key;
        this.node = node;
    }
    print() {
        console.log(`Node(${this.key})`);
    }
}

class LinkedList {
    constructor() {
        this.head = new Node(null, null);
        this.z = new Node(null, null);
        this.head.next = this.z;
        this.z.next = this.z; // Sentinel node
    }

    delete_next(node) {
        node.next = node.next.next;
    }

    insert_after(value, node) {
        const newNode = new Node(value, node.next);
        node.next = newNode;
        return newNode;
    }
    print() {
        let current = this.head.next;
        while (current != null) {
            current.print();
            current = current.next;
        }
    }
}


function main() {
    const linkedList = new LinkedList();
    nodeOne = linkedList.insert_after(5, linkedList.head);
    nodeTwo = linkedList.insert_after(10, nodeOne);
    nodeThree = linkedList.insert_after(15, nodeTwo);

    console.log("Print linkedList")
    linkedList.print()

    console.log(`delete ${nodeTwo.key}`);
    linkedList.delete_next(nodeOne);
    console.log("\nPrint linkedList");
    linkedList.print();
}

main();
</code></pre>
<h4 id="thoughts-1"><a class="header" href="#thoughts-1">Thoughts:</a></h4>
<p>JavaScript is strange, VS Code is strange and I'm so tired that I am surprised I was able to do anything.</p>
<p>Also, I hate the copilit suggestions. It interrupts my thoughts. No matter what I do, the suggestions are still there?!</p>
<p>I think the suggestions are gone... FINALLY!</p>
<h2 id="linked-list----continued"><a class="header" href="#linked-list----continued">Linked List -- Continued</a></h2>
<p>The reader is encouraged to check these C implementations against the English language description given above. In particular, it is instructive at this stage to consider why the dummy nodes are useful. First, if the convention were to have <code>head</code> point to the beginning of the list rather than having a <code>head</code> node, then the <code>insert</code> procedure would need a special test for insertion at the beginning of the list. Second, the convention for <code>z</code> protects the <code>delete</code> procedure from (for exampe) a call to delete an item from an empty list.</p>
<p>Another common convention for terminating a list is to make the last node point to the first, rather than using either of the dummy odes <code>head</code> of <code>z</code>. This is called a <em>circular list</em>: it allows a program to go around and around the list. Using one dummy node to mark the beginning (and the end) of the list and to help handle the case of the empty list is sometimes convenient.</p>
<p>It is possible to support the operation "find the item <em>before</em> a given item" by using a <em>doubly linked list</em> in which we maintain two links for each node, one to the item before, one to the item after. The cost of providing this extra capability is doubling the number of link manipulations per basic operation, so it is not normally used unless specifically called for. As mentioned above, however, if a node is to be deleted and only a link to the node is available (perhaps it is also part of some other data structure), double linking may be called for.</p>
<div id="admonition-note-5" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-5-title">
<div class="admonition-title">
<div id="admonition-note-5-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-5"></a>
</div>
<div>
<p>The "Josephus problem" describe in the next paragraph would never be written in a modern book, but I find it very interesting that something like this was every okay to mention in a tech book.</p>
</div>
</div>
<p>We'll see many examples of applications of these and other basic operations on linked lists in later chapters. Since the operations involve only a few statements, we noramlly manipulate the list directly rather than use the precise procedure above. As an example, we consider next a program for solving the so-called "Josephus problem" in the spirit of Eratosthenes. We imagine that <code>N</code> people have decided to commit mass suicide by arranging themselves in a circle and killing the <code>M</code>th persion around the circle, closing ranks as each person drops out of the circle. The problem is to find out which person is the last to die (though perhaps that person would have a change of heart at the end!), or, more generally, to find the order in which the people are executed. For example, if <code>N</code> = 9 and <code>M</code> = 5, then people are killed in the order of 5, 1, 7, 4, 3, 6, 9, 2, 8. The following program reads in <code>N</code> and <code>M</code> and prints out this ordering:</p>
<h3 id="c-implementation-2"><a class="header" href="#c-implementation-2">C implementation</a></h3>
<div id="admonition-note-6" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-6-title">
<div class="admonition-title">
<div id="admonition-note-6-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-6"></a>
</div>
<div>
<p>The original code does not have comments. I added them for clarity.</p>
</div>
</div>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
  int key;
  struct node *next;
}

main() {
  int i, N, M;
  struct node *t, *x;

  // Capture user input
  scanf("%d %d", &amp;N, &amp;M);

  // Creating the linked list of number
  t = (struct node *)malloc(sizeof *t);
  t-&gt;key = 1;
  x = t;
  for (i = 2; i &lt;= N; i++) {
    t-&gt;next = (struct node *)malloc(sizeof *t);
    t = t-&gt;next;
    t-&gt;key = i;
  }

  // Pointing the last node to the first node.
  // Makes the linked list circular
  t-&gt;next = x;

  // Josephus problem
  while (t != t-&gt;next) {
    for (i = 1; i &lt; M; i++)
      t = t-&gt;next;
    printf("%d ", t-&gt;next-&gt;key);
    x = t-&gt;next;
    t-&gt;next = t-&gt;next-&gt;next;
    free(x);
  }
  printf("%d\n", t-&gt;key);
}
</code></pre>
<h3 id="python-implementation-1"><a class="header" href="#python-implementation-1">Python Implementation</a></h3>
<p>The Python code stays pretty true to the C implementation.</p>
<div class="repl" data-id="9cb97b32-ed2a-49cb-bd41-1e34e95a86c2" data-readonly="false" data-lang="python">
  <iframe class="hide" loading="lazy" name="mdbook-python-repl" allow="clipboard-write" src="https://mr-addict.github.io/mdbook-repl/embed/"></iframe>
</div>
<pre><code class="language-python">class Node:
    def __init__(self, key, next=None):
        self.key = key
        self.next = next


def main():
    node = Node(1, None)

    # Capture user input
    N, M = input("Set N and M (example: '9 5': ").split()
    N = int(N)
    M = int(M)

    # Create linked list
    first_node = node
    for x in range(2, N + 1):
        node.next = Node(x)
        node = node.next

    # Make the linked list into a circular linked list
    node.next = first_node

    # Josephus problem
    while node != node.next:
        for _ in range(1, M):
            node = node.next
        print(f"{node.next.key}", end=" ")
        node.next = node.next.next

    print(f"{node.key}")


if __name__ == "__main__":
    main()
</code></pre>
<h3 id="rust-implementation-2"><a class="header" href="#rust-implementation-2">Rust Implementation</a></h3>
<p>In Rust, I cannot use Linked List in they way Python and C do it, so I implemented a (bad) solution to the problem using a Vec.</p>
<pre><code class="language-Rust">use std::io;

fn main() {
    println!("Set N and M (example: '9 5'):");

    // Capture user input
    let mut buffer = String::new();
    io::stdin().read_line(&amp;mut buffer).unwrap();

    // Parse user input
    let data: Vec&lt;usize&gt; = buffer
        .split_whitespace()
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .iter()
        .map(|x| x.parse().expect("Expect a digit"))
        .collect();

    #[allow(non_snake_case)]
    let N = data[0];
    #[allow(non_snake_case)]
    let M = data[1];

    // Create List
    let mut list: Vec&lt;usize&gt; = (1..=N).collect();

    // Josephus problem
    while list.len() &gt; 1 {
        for _ in 1..M {
            // Rotate the items in the list to the left
            list.rotate_left(1);
        }
        let data = list.remove(0);
        print!("{data} ")
    }
    print!("{}", list[0]);
}
</code></pre>
<h2 id="back-to-the-book"><a class="header" href="#back-to-the-book">Back to the Book:</a></h2>
<p>The program uses a circular linked list to simulate the sequence of executions directly. First, the list is built with keys from 1 to <code>N</code>: the variable <code>x</code> holds onto the beginning of the list as it is built, then the pointer in the last node in the list is set to <code>x</code>. Then, the program proceeds through the list, counting through <code>M</code> - 1 items and deleting the next, until only one is left (which then points to itself). Note the call to <code>free</code> for the delete, which corresponds to an execution: this is the opposite of <code>malloc</code> as mentioned before.</p>
<h2 id="storage-allocation"><a class="header" href="#storage-allocation">Storage Allocation</a></h2>
<p>C's pointers provide a convenient way to implement lists, as shown above, but there aere alternatives. In this section we discuss how to use <code>arrays</code> to implement linked lists and how this is related to the actual representation of memory of a computer, so that analysis of how a data structure is implemented as an array will give you some insight into how it might be represented at a low level in the computer. In particular, we're interested in seeing how several lists might be represented simultaneously.</p>
<p>In a direct-array representation of linked lists, we use indices instead of links. One way to proceed would be to define an array of records like those above, but using <code>integers</code> (for array indices) rather than pointers for the <code>next</code> field. An alternative, which often turns out to be more convenient, is to use "parallel arrays": we keep the items in an array <code>key</code> and the links in an array <code>next</code>. Thus, <code>key[next][head]</code> refers ti the information associated with the first item on the list, <code>key[next[next[head]]]</code> to the second, etc. The advantage of using parallel arrays is that the structure can be built "on top of" the data: the array <code>key</code> contains data and only data -- all the structure is in the parallel array <code>next</code>. For example, another list can be built using the same data array and a different parallel "link" array, or more data can be added with more parallel arrays. The following code implements the basic list operations using parallel arrays:</p>
<h3 id="c-implementation-3"><a class="header" href="#c-implementation-3">C Implementation:</a></h3>
<p>The errors you get when you try to compile code snippets from books can be rough, especially when you do not know the language well.</p>
<pre><code class="language-c">/*
  The original code used `max+2` and not 12.

  I changed it because it was giving me compile errors.
 */
int key[12], next[12];
int x, head, z;

int listinitialize()
{
  head = 0; z = 1; x = 2;
  next[head] = z; next[z] = z;
 };
int deletenext(int t)
  { next[t] = next[next[t]]; };
int insertafter(int v, int t)
{
  key[x] = v; next[x] = next[t];
  next[t] = x;
  return x++;
};

int main(){
}
</code></pre>
<h3 id="rust-implementation-3"><a class="header" href="#rust-implementation-3">Rust Implementation:</a></h3>
<p>I wrote this about two weeks ago, so I am a bit fuzzy on how I felt at the time of writing it. All I know is that I spent hours trying to write a node based linked list and, after giving up, I came back, I think a day later, and struggled translating this to Rust. I believe the tricky part was getting the indices right. If <code>insert_after</code> does not return the correct value for the next index, everything becomes wonky.</p>
<pre><code class="language-Rust">const SIZE: usize = 10;

#[derive(Debug)]
struct List&lt;T&gt;
where
    T: Default + std::fmt::Debug + Copy,
{
    head: usize,
    z: usize,
    x: usize,

    key: [T; SIZE],
    next: [usize; SIZE],
}

impl&lt;T: Default + std::fmt::Debug + Copy&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        let head = 0;
        let z = 1;
        let x = 2;
        // The Copy Trait is being used here because the default value is being
        // copied for each place holder
        let key = [T::default(); SIZE];
        let mut next = [0; SIZE];

        next[head] = z as usize;
        next[z] = z as usize;

        Self {
            head,
            z,
            x,
            key,
            next,
        }
    }

    pub fn delete_next(&amp;mut self, t: usize) {
        self.next[t] = self.next[self.next[t]]
    }

    pub fn insert_after(&amp;mut self, v: T, t: usize) -&gt; usize {
        self.key[self.x] = v;
        self.next[self.x] = self.next[t];
        self.next[t] = self.x;
        self.x += 1;
        self.x - 1
    }

    pub fn print(&amp;self) {
        let mut n = self.next[0];

        while n != self.z {
            println!("{:?}", self.key[n]);
            n = self.next[n];
        }
    }
}

fn main() {
    let mut list: List&lt;i32&gt; = List::new();
    let mut next = list.insert_after(5, 0);
    for x in [10, 15, 20] {
        next = list.insert_after(x, next);
        println!("{:?} -- next: {next}", list);
    }
    list.insert_after(100, next);
    println!("{:?}", list);

    list.print();

    list.delete_next(4);
    println!("{:?}", list);
    list.print();
}
</code></pre>
<h2 id="continue-the-book"><a class="header" href="#continue-the-book">Continue the Book</a></h2>
<p>Each call on the storage allocation function <code>malloc</code> is replaced by simply incrementing the "pointer" <code>x</code>: it keeps track of the next unused position in the array.</p>
<div id="admonition-note-7" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-7-title">
<div class="admonition-title">
<div id="admonition-note-7-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="#admonition-note-7"></a>
</div>
<div>
<p>I'm skipping the Figure examples in this section because I cannot draw them.</p>
</div>
</div>
<p>The crux of the matter is to consider how the built-in procedures <code>malloc</code> and <code>free</code> might be implemented. We presume that the only space for nodes and links are the arrays we've been using; this presumption puts us in the situation the system is in when it has to provide the capability to grow and shrink a data structure wuth a fixed data structure (the memory itself). For example, suppose that the node containing <code>A</code> is to be deleted from the example in Figure 3.5 and then disposed of. It is one thing to rearrange the links so that node is no longer hooked into the list, but what do we do with the space occupied by that node? And how do we find space for a node when <code>new</code> is called and more space is needed?</p>
<p>On reflection, the reader will see that the solution is clear: a linked list should be used to keep track of the free space! We refer to this list as the "free list." Then, when we <code>delete</code> a node from our list we dispose of it by <code>inserting</code> it into the free list, and when we need a <code>new</code> node, we get it by <code>deleting</code> it from the free list. This mechanism allows several different lists to occupy the same array.</p>
<p>When storage management is provided by the system, as in C, there is no reason to override in this way. The description above is intented to indicate how the storage management is done by the system. The actual problem faced by the system is rather more complex, as not all nodes are necessarily of the same size. Also, some systems relieve the user of the need to explicitly <code>free</code> nodes by using <code>garbage-collection</code> algorithms to remove any nodes not referenced by any link. A number of rather clever storage management algorithms have been developed to handle these two situations.</p>
<h2 id="pushdown-stacks"><a class="header" href="#pushdown-stacks">Pushdown Stacks</a></h2>
<p>We have been concentrating on structuring data in order to insert, delete, or access items arbitrarily. Actually, it turns out that for many applications, it suffices to consider various (rather stringent) restrictions on how the data structure is accessed. Such restrictions are beneficial in two ways: first, they can alleviate the need for the program using data structure to be concerned with its details (for example, keeping track of links to or indices of items); second, they allow simpler and more flexible implementations, since fewer operations need be supported.</p>
<p>The most important restricted-access data structure is the <code>pushdown stack</code>. Only two basic operations are involved: one can <code>push</code> an item into the stack (insert it at the beginning) and <code>pop</code> an item (remove it from the beginning). A stack operates somewhat like a busy executive's "in" box: work piles up in a stack, and whenever the executive is ready to do some work, he takes it off the top. This might mean that something get stuck in the bottom of the stack for some time, but a good executive would presumably manage to get the stack emptied periodically. It turns out that sometimes a computer program is naturally organized in this way, postponing some tasks while doing others, and thus pushdown stacks appear as the fundamental data structure for many algorithms.</p>
<p>We'll see a great many applications of stacks in the chapters that follow: for an introductory example, let's look at using stacks in evaluating arithmetic expressions. Suppose that one wants to find the value of a simple arithmetic expression involving multiplication and addition of integers, such as:</p>
<pre><code>5 * (((9 + 8) * (4 * 6)) + 7
</code></pre>
<p>A stack is the ideal mechanism for saving intermediate results in such a calculation. The above example might be computed with the calls:</p>
<pre><code>push(5);
push(9);
push(8);
push(pop() + pop());
push(4);
push(6);
push(pop()*pop());
push(pop()*pop());
push(7);
push(pop()+pop());
push(pop()*pop());
printf("%d\n", pop());
</code></pre>
<p>The order in which the operations are performed is dictated by the parentheses in the expression, and by the convention that we proceed from left to right. Other conventions are possible; for example 4*6 could be computed before 9+8 in the example above. And in C, the order in which the two <code>pop()</code> operations is performed is unspecified, so slightly more complicated code is needed for noncommutative operators such as subtract and divide.</p>
<p>Some calculators and some computing languages base their method of calculation on stack operations explicitly: every operations pops its argument from the stack and returns its results to the stack. As we'll see in Chapter 5, stacks often arise implicitly even when not used explicitly.</p>
<p>The basic stack operations are easy to implement using linked lists as in the following implementation:</p>
<h3 id="c-implementation-4"><a class="header" href="#c-implementation-4">C Implementation</a></h3>
<!-- Custom REPL Script -->
<script>
  document.querySelectorAll(".repl").forEach((replElement) => {
    const iframeElement = replElement.querySelector("iframe");
    const id = replElement.getAttribute("data-id");
    const lang = replElement.getAttribute("data-lang");
    const code = getCode(replElement.nextElementSibling);
    const readonly = replElement.getAttribute("data-readonly") === "true";
    let theme = mapTheme(localStorage.getItem("mdbook-theme") || document.querySelector(".theme.theme-selected")?.id);
    const postmessage = (msg) => iframeElement.contentWindow.postMessage({ repl: msg }, "*");
    function mapTheme(bookTheme) {
      return bookTheme === "light" || bookTheme === "rust" ? "light" : "dark";
    }
    function getCode(element) {
      // remove all the boring elements
      const code = element.cloneNode(true);
      code.querySelectorAll(".boring").forEach((boring) => boring.remove());
      return code.innerText.trim();
    }
    window.addEventListener("message", (event) => {
      const repl = event.data.repl;
      if (event.source === window || !repl) return;
      // if the id is empty, then it's the first time the iframe is loaded
      if (repl.id === "") {
        postmessage({ id, editor: { theme, lang, code, readonly, defaultCode: code } });
        return;
      }
      if (repl.id !== id) return;
      // update the iframe height
      replElement.style.height = repl.dimensions.height + "px";
      // show the iframe and hide the pre element
      iframeElement.classList.remove("hide");
      replElement.nextElementSibling.style.display = "none";
    });
    // listen to theme change
    document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => {
      btn.addEventListener("click", (event) => {
        theme = mapTheme(event.target.id);
        postmessage({ id, editor: { theme } });
      });
    });
  });
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../algortihms_in_c/chapter_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../advent_of_code/2015/day_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../algortihms_in_c/chapter_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../advent_of_code/2015/day_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
